---
title: "[Algorithm]1. LeetCode-FindMaxWaterArea"
categories:
  - Algorithm
tags:
excerpt: LeetCode Medium Problem
use_math: true
comments: true

---


## 0. Problem Description.

![MaxWaterContainer](./assets/MaxWater.PNG)
문제는 컨테이너 들어갈 n 개의 위치(coordinate)가 주어지고
그 위치에서의 높이가 주어진다 (height), 우리가 찾아야 할 것은, n개의 컨테이너 중 2개의 컨테이너를 선택해서, 물이 세지 않게 하는 가능한 많은 물을 수용할 수 있게끔 하는 것이다. 
예를 들어보자면, 사진에서처럼 2번과 9번을 컨테이너로 잡으면, 양측에서 물이 세면 안되므로 물의 높이는 2번을 기준으로 해야한다. 따라서, 2번과 9번을 컨테이너로 잡으면, 가능한 물의 높이는 (9-2)*min(2번의 heigth, 9번의 height)인 49이다. (이 경우가 문제의 정답이다.)

## 1. Brute Force
내가 첫번째로 접근한 방법은 __브루트 포스__ 방법으로, 1~8번막대별로 가능한 모든 컨테이너의 경우를 찾아 그 경우별로 수용가능한 물의 넓이를 찾아서, 최대로 수용가능한 물의 넓이를 찾는것이다. 알고리즘 복잡도는 $O(n^2)$이다.
'''



'''

## 2. Improved Solution
Brute Force방법으로 문제를 풀고나니, 효율성에 문제가 생겼다.(Brute Force를 그대로 사용하면 아마 런타임 에러가 날 것이다.)

````cpp
#include<vector>
#include<iostream>
#include<cmath>
using namespace std;
class Solution {
public:
    int maxArea(vector<int>& height)
    {

        //improved O(n) solution..
        int max_water = 0;
        int i = 0;
        int j = height.size()-1;
        while (i < j)
        {
            int cur_width = j - i;
            int cur_height = min(height[i], height[j]);
            int cur_water = cur_width * cur_height;
            if (max_water < cur_water) max_water = cur_water;
            if (height[i] > height[j]) j--;
            else i++;

        }


        return max_water;


    }
};

````