---
title: "[Algorithm]1. LeetCode-FindMaxWaterArea"
categories:
  - Algorithm
tags:
excerpt: LeetCode Medium Problem
use_math: true
comments: true

---


## 0. Problem Description.

![MaxWaterContainer](./assets/MaxWater.PNG)
문제는 컨테이너 들어갈 n 개의 위치(coordinate)가 주어지고
그 위치에서의 높이가 주어진다 (height), 우리가 찾아야 할 것은, n개의 컨테이너 중 2개의 컨테이너를 선택해서, 물이 세지 않게 하는 가능한 많은 물을 수용할 수 있게끔 하는 것이다. 
예를 들어보자면, 사진에서처럼 2번과 9번을 컨테이너로 잡으면, 양측에서 물이 세면 안되므로 물의 높이는 2번을 기준으로 해야한다. 따라서, 2번과 9번을 컨테이너로 잡으면, 가능한 물의 높이는 (9-2)*min(2번의 heigth, 9번의 height)인 49이다. (이 경우가 문제의 정답이다.)

## 1. Brute Force
내가 첫번째로 접근한 방법은 __브루트 포스__ 방법으로, 1~8번막대별로 가능한 모든 컨테이너의 경우를 찾아 그 경우별로 수용가능한 물의 넓이를 찾아서, 최대로 수용가능한 물의 넓이를 찾는것이다. 알고리즘 복잡도는 $O(n^2)$이다.
````cpp
#include<vector>
#include<iostream>
#include<cmath>
using namespace std;
class Solution {
public:
    int maxArea(vector<int>& height)
    {
        //brute force this one is totally brute foce with O(n^2): didnt pass leetcode time limit
        int max_water = 0;
        //for (int i = 0; i < height.size(); i++)
        //{
        //    int left = height[i];
        //    for (int j = i+1; j < height.size(); j++)
        //    {
        //        int width = j - i;
        //        int cur_height= min(left, height[j]);
        //        int cur_capa = width * cur_height;
        //        if (cur_capa > max_water)
        //            max_water = cur_capa;
        //    }

        //}


        //improved this will be lesser than O(n^2 )but still takes alot of time passed a time limit..
        int max_left = -1;
        max_water = max_left;
        for (int i = 0; i < height.size(); i++)
        {
            if (max_left >= height[i]) //dont have to check ith coordinate..
                continue;

            int cur_left = height[i]; // same as Brute force..
            for (int j = i + 1; j < height.size(); j++)
            {
                int width = j - i;
                int cur_height = min(cur_left, height[j]);
                int cur_capa = width * cur_height;
                if (cur_capa > max_water)
                {
                    max_water = cur_capa;
                    max_left = height[i]; //if maximum changes, than left  chosed container will also be changed..
                }
            }

        }


        return max_water;


    }
};
````

위에 주석처리된 코드는 순수하게 조건문하나 없이 Brute Force방법으로 한것이고, 타임 리밋을 패스하지 못했다. 브루트 포스를 작성하고나니 문제가 몇가지 보여서, 이후 몇가지 아이디어를 가지고 코드를 조금씩 수정했는데, 이건 다음코드들을 보면서 설명을 하겠습니다.

## 2. Improved Solution
Brute Force방법으로 문제를 풀고나니, 효율성에 문제가 생겼다. 하지 않아도 될 계산을 너무많이 반복하는걸 발견했다. 예를들어 현재 컨테이너보다 다음컨테이너의 높이가 더낮으면, 다음 컨테이너는 계산할 필요가 없어진다. 
첫번째로 고안한 방법은 위에 코드에서 주석처리되지 않은 부분인데, 현재 컨테이너보다 다음위치에 있는 컨테이너를 선택한다고 할때, 다음 위치에 있는 컨테이너의 높이가 현제 컨테이너높이보다 낮을경우, 계산할 필요가 없어진다는 것이다. 이를 조건문속에넣어서 코드를 수정했더니 Time limit은 pass했지만, 여전히 느린코드였고, 최악의 상황에서 $O(n^2)$임은 변하지 않았다. 그래서 고안한코드가 아래 코드다..

````cpp
#include<vector>
#include<iostream>
#include<cmath>
using namespace std;
class Solution {
public:
    int maxArea(vector<int>& height)
    {

        //improved O(n) solution..
        int max_water = 0;
        int i = 0;
        int j = height.size()-1;
        while (i < j) //we dont have to check when j>i
        {
            int cur_width = j - i;
            int cur_height = min(height[i], height[j]);
            int cur_water = cur_width * cur_height;
            if (max_water < cur_water) max_water = cur_water;
            if (height[i] > height[j]) j--;
            else i++;

        }


        return max_water;


    }
};

````
첫번째 수정본에서는 한쪽방향에서의 효율성을 고려했다면, 최종본에서는 양쪽컨테이너를 동시에 고려하는 방법을 사용했다.
이 코드는 양쪽 끝에서 시작하여, 양쪽에서 선택된 컨테이너들 중에서, 높이가 작은쪽을 이동시키고(높이가 큰쪽을 이동시켜봤자, 넓이가 더 커질 수 없다.), 큰쪽은 그대로 놔두는 알고리즘이다. $O(n^2)$의 복잡도를 가지며, 코드가 훨씬 간결해지고, 빨라졌다. 
순차적으로 브루트 포스-> 브루트포스의 수정-> 새로운 방법의 순으로 내가 짠 코드들을 살펴보았다.
